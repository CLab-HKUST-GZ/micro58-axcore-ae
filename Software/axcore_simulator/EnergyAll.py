import matplotlib.pyplot as plt
import numpy as np
from matplotlib.patches import Patch
from matplotlib.gridspec import GridSpec, GridSpecFromSubplotSpec


# Set font to Times New Roman
plt.rcParams['font.family'] = 'Times New Roman'
plt.rcParams['mathtext.fontset'] = 'custom'
plt.rcParams['mathtext.rm'] = 'Times New Roman'
plt.rcParams['mathtext.it'] = 'Times New Roman:italic'
plt.rcParams['mathtext.bf'] = 'Times New Roman:bold'


# Font configuration dictionary
font_config = {
    'title'      : 30,
    'axis_label' : 30,
    'legend'     : 30,
    'tick_label' : 27,
    'bar_label'  : 25,
    'group_label': 28,
    'extra_label': 28,
}


# Raw data (baseline values for each main category)
groups = [
    'OPT-13B', 'OPT-30B',
    'OPT-13B', 'OPT-30B',
    'OPT-13B', 'OPT-30B',
    'OPT-13B', 'OPT-30B',
    'OPT-13B', 'OPT-30B',
    'OPT-13B', 'OPT-30B',
    'Average'
]
extra_labels = [
    'W4-FP16',
    'W4-BF16',
    'W4-FP32',
    'W8-FP16',
    'W8-BF16',
    'W8-FP32',
    'Average'
]
categories = ['FPC', 'FPMA', 'FIGNA', 'FIGLUT', 'AxCore']

def load_csv_data():
    """Load energy data from axcore_res.csv generated by fig_17.sh"""
    
    # Read the CSV file
    with open('./results/axcore_res.csv', 'r') as f:
        lines = f.readlines()
    
    # Parse data for each configuration
    config_data = []
    i = 0
    while i < len(lines):
        line = lines[i].strip()
        if line.startswith('Configuration:'):
            # Extract energy data for this configuration
            # Energy data starts at line i+7 (Static), i+8 (Dram), i+9 (Buffer), i+10 (Core)
            static_line = lines[i + 7].strip().split(', ')[1:11]  # Columns 1-10 (Opt13B and Opt30B)
            dram_line = lines[i + 8].strip().split(', ')[1:11]    
            buffer_line = lines[i + 9].strip().split(', ')[1:11]  
            core_line = lines[i + 10].strip().split(', ')[1:11]   
            
            # Reshape data: [Opt13B_5configs, Opt30B_5configs] -> [2benchmarks][5configs][4components]
            opt13b_data = []
            opt30b_data = []
            
            for j in range(5):  # 5 hardware configs (AxCore, FGLUT, FIGNA, FPMA, FPE)
                opt13b_data.append([
                    float(static_line[4-j]), float(dram_line[4-j]), 
                    float(buffer_line[4-j]), float(core_line[4-j])
                ])
                opt30b_data.append([
                    float(static_line[4-j+5]), float(dram_line[4-j+5]), 
                    float(buffer_line[4-j+5]), float(core_line[4-j+5])
                ])
            
            config_data.extend([opt13b_data, opt30b_data])
            i += 12  # Skip to next configuration
        else:
            i += 1
    
    return np.array(config_data, dtype=object)

def load_csv_core_ratios():
    """Load core ratio data from axcore_res.csv (FPE core / each config's core)"""
    
    # Read the CSV file
    with open('./results/axcore_res.csv', 'r') as f:
        lines = f.readlines()
    
    # Parse data for each configuration
    config_data = []
    i = 0
    while i < len(lines):
        line = lines[i].strip()
        if line.startswith('Configuration:'):
            # Extract core energy data for this configuration
            # Core data is at line i+10
            core_line = lines[i + 10].strip().split(', ')[1:11]  # Columns 1-10 (Opt13B and Opt30B)
            
            # Calculate ratios: FPE_core / each_config_core
            opt13b_ratios = []
            opt30b_ratios = []
            
            # For Opt13B (first 5 values): FPE is at index 4, others at 0,1,2,3,4
            fpe_core_opt13b = float(core_line[4])  # FPE core value for Opt13B
            for j in range(5):  # 5 hardware configs (AxCore, FGLUT, FIGNA, FPMA, FPE)
                config_core = float(core_line[4-j])  # Reverse order to match categories
                ratio = fpe_core_opt13b / config_core if config_core != 0 else 1.0
                opt13b_ratios.append([ratio])
            
            # For Opt30B (next 5 values): FPE is at index 9, others at 5,6,7,8,9
            fpe_core_opt30b = float(core_line[9])  # FPE core value for Opt30B
            for j in range(5):  # 5 hardware configs (AxCore, FGLUT, FIGNA, FPMA, FPE)
                config_core = float(core_line[4-j+5])  # Reverse order to match categories
                ratio = fpe_core_opt30b / config_core if config_core != 0 else 1.0
                opt30b_ratios.append([ratio])
            
            config_data.extend([opt13b_ratios, opt30b_ratios])
            i += 12  # Skip to next configuration
        else:
            i += 1
    
    return np.array(config_data, dtype=object)

# Sub-value percentage configuration
percentages = []
percentages.append(load_csv_data())

percentages.append(load_csv_core_ratios())

# Calculate the average of each sub-value
for i in range(len(percentages)):
    average = []
    for j in range(len(percentages[i][0])):
        avg = [0] * len(percentages[i][0][0])

        for k in range(len(percentages[i][0][0])):
            current_sum = 0
            for n in range(len(percentages[i])):
                current_sum += percentages[i][n][j][k]
            avg[k] = current_sum / len(percentages[i])
        average.append(avg)
    percentages[i] = np.append(percentages[i], [average], axis=0)


labels = []
for group in groups:
    for cat in categories:
        labels.append(f"{group}-{cat}")

sub_textures=[
    {
        'Static'  : {'color': '#CCE5FE', 'hatch': '/'},
        'Dram'    : {'color': '#A2C6EB', 'hatch': '\\\\'},
        'Buffer'  : {'color': '#78A7D8', 'hatch': 'xx'},
        'Core'    : {'color': '#236AB3', 'hatch': '||'},
    },
    {
        'Core'    : {'color': '#236AB3', 'hatch': '||'},
    }
]

sub_textures.append({
    'TOPS/W'  : {'color': '#236AB3', 'hatch': ''},
})
print(sub_textures[0])


# Plotting configuration
style_config = {
    'figsize'               : (30, 11),
    'bar_width'             : 0.4,
    'bar_spacing'           : 0.2,
    'label_offset'          : 0.01,
    'group_label_offset_x'  : 0.5,      # x-axis offset for group labels
    'group_label_offset_y'  : -0.57,    # y-axis offset for group labels
    'group_spacing'         : 0.2,      # group spacing
    'margin'                : 0.2,
    'boundary_linewidth'    : 1.5,
}

def create_stacked_subplot(ax, labels, label_ax, extra_labels, stacked_values, ylabel,
                           ylabel_position=None, ylimit=(0, 1), label_limit=1, fraction_bits=2,
                           show_labels=True, show_group_labels = True, show_extra_labels=True, show_extra_lines=True, 
                           sub_textures=None, bar_width=0.6, bar_spacing=0.8, group_spacing=1, margin=0.02,
                           label_offset=0.05, group_label_offset_x=0.42, group_label_offset_y=0.15):
    """Creates a stacked subplot."""
    # Calculate x-axis positions
    x_positions = []
    offset = 0
    for group in groups:
        x = np.arange(len(categories)) * (bar_width + bar_spacing) + offset
        x_positions.append(x)
        offset += len(categories) * (bar_width + bar_spacing) + group_spacing
    x_positions_flat = np.concatenate(x_positions)
    
    for x_group, val_group, in zip(x_positions, stacked_values):
        for (x_bar, val_bar) in zip(x_group, val_group):
            bottom = 0
            
            for i, sub_val in enumerate(val_bar):
                sub_cat = list(sub_textures.keys())[i]
                texture = sub_textures[sub_cat]
                ax.bar(x_bar, sub_val, width=bar_width, 
                       bottom=bottom,
                       color=texture['color'],
                       hatch=texture['hatch'],
                       edgecolor='black', 
                       linewidth=0.8)
                bottom += sub_val  

            if bottom < label_limit:
                format_str = f"{{:.{fraction_bits}f}}"
                ax.text(x_bar, bottom + label_offset*(ylimit[1]-ylimit[0]), format_str.format(bottom),
                        ha='center', va='bottom', fontweight='bold',
                        fontsize=font_config['bar_label'],
                        rotation=90)
    
    # Set x-axis
    ax.set_xlim(
        x_positions_flat[0] - bar_width/2 - margin,
        x_positions_flat[-1] + bar_width/2 + margin
    )
    
    # Set y-axis
    ax.set_ylabel(ylabel, fontsize=font_config['axis_label'])
    if ylabel_position != None:
        ax.yaxis.set_label_coords(ylabel_position[0], ylabel_position[1])
    ax.tick_params(axis='y', labelsize=font_config['tick_label'])
    ax.set_ylim(ylimit[0], ylimit[1]) 
    ax.grid(axis='y', linestyle='--', alpha=0.3)

    # Set bottom x-axis labels (main category labels)
    if show_labels:
        ax.set_xticks(x_positions_flat)
        ax.set_xticklabels([label.split('-')[-1] for label in labels],
                           fontsize=font_config['tick_label'],
                           rotation=90)
        ax.tick_params(axis='x', length=0, pad=15)
        ax.xaxis.set_ticks_position('bottom')
    else:
        ax.set_xticks([])
        ax.set_xticklabels([])
    
    # Add group_label to group (only when show_group_labels is True)
    if show_group_labels:
        x_min_pos = [x.min() for x in x_positions]
        x_range = [x[-1] - x[0] for x in x_positions]
        # Get the current y-axis range
        y_min, y_max = ax.get_ylim()
        y_range = y_max - y_min
        # Calculate the y-coordinate position of the label (relative to the y-axis range)
        label_y = y_min + y_range * group_label_offset_y

        for x, width, group in zip(x_min_pos, x_range, groups):
            label_x = x + (width * group_label_offset_x)
            ax.text(label_x, label_y, group, 
                    ha='center', va='top', 
                    fontsize=font_config['group_label'], fontweight='bold',
                    bbox=dict(facecolor='white', edgecolor='none', pad=0))
        
        # Add group separator lines
        for i in range(len(groups)-1):
            boundary = x_positions[i][-1] + (bar_width + group_spacing + margin) / 2
            ax.axvline(x=boundary, color='black', linewidth=style_config['boundary_linewidth'],
                       ymin=-1, ymax=0, clip_on=False)
        # Add left and right borders for the negative y-axis
        x_min, x_max = ax.get_xlim()
        ax.axvline(x=x_min, color='black', linewidth=style_config['boundary_linewidth'],
                       ymin=-1, ymax=0, clip_on=False)
        ax.axvline(x=x_max, color='black', linewidth=style_config['boundary_linewidth'],
                       ymin=-1, ymax=0, clip_on=False)
    
    # Add extra_labels
    label_ax.axis('off')
    label_ax.set_xlim(
        x_positions_flat[0] - bar_width/2 - margin,
        x_positions_flat[-1] + bar_width/2 + margin
    )
    for i, x_group in enumerate(x_positions):
        x_extra_label = x_group[-1] + (bar_width + group_spacing + margin) / 2
        width = x_group[-1] - x_group[0]

        if show_extra_labels:
            # extra_labels
            if(i % 2 == 0 and i != len(x_positions)-1):
                label_ax.text(x_extra_label , 0.5, extra_labels[i//2], fontsize=font_config['extra_label'], 
                              fontweight='bold', ha='center', va='top')
            elif(i == len(x_positions)-1):
                label_ax.text(x_group[0] + width/2, 0.5, extra_labels[i//2], fontsize=font_config['extra_label'], 
                              fontweight='bold', ha='center', va='top')
        if show_extra_lines:
            # extra_labels separator line
            if(i % 2 == 1):
                ax.axvline(x=x_extra_label, color='black', linewidth=style_config['boundary_linewidth'],
                   ymin=0, ymax=1, clip_on=False)

    # Set border style
    for spine in ax.spines.values():
        spine.set_visible(True)
        spine.set_edgecolor('black')
        spine.set_linewidth(style_config['boundary_linewidth'])  
    

# Create subplots
fig = plt.figure(figsize=style_config['figsize'])

if not extra_labels:
    gs = fig.add_gridspec(2, 1, height_ratios=[0.15, 0.85])
    legend_ax = fig.add_subplot(gs[0])  # Legend area
    main_ax = fig.add_subplot(gs[1])    # Main chart area
else:
    gs = fig.add_gridspec(5, 1, height_ratios=[0.02, 0.06, 0.53, 0.03, 0.36])
    legend_ax = fig.add_subplot(gs[0])  # Legend area
    label_ax = fig.add_subplot(gs[1])   # extra_labels area
    main_ax0 = fig.add_subplot(gs[2])   # Main chart area 0
    space_ax = fig.add_subplot(gs[3])   # Spacer area
    main_ax1 = fig.add_subplot(gs[4])   # Main chart area 1

# Hide axes for legend and spacer areas
legend_ax.axis('off')
space_ax.axis('off')

# Create legend handles
legend_elements = []
for sub_cat, texture in sub_textures[0].items():
    # Create a patch with the correct texture
    patch = Patch(
        facecolor=texture['color'],
        hatch=texture['hatch'],
        edgecolor='black',
        linewidth=0.8,
        label=sub_cat
    )
    legend_elements.append(patch)

# Reverse legend order
legend_elements.reverse()

# Create legend in the dedicated legend area
legend_ax.legend(
    handles=legend_elements,
    loc='center',  # Center alignment
    ncol=4,  # 4 columns, all elements in one row
    frameon=True,
    fontsize=font_config['legend'] - 1,
    title_fontsize=font_config['legend'],
    # framealpha=1.0,
    labelspacing=0.5,
    handlelength=1.5,
    handletextpad=0.5,
    edgecolor='black',
)

# Generate main charts
create_stacked_subplot(
    main_ax0,
    labels=labels,
    label_ax=label_ax,
    extra_labels=extra_labels,
    stacked_values=percentages[0],
    ylabel='Normalized Energy',
    ylimit=(0, 1),
    label_limit=1,
    fraction_bits=2,
    show_labels=False,
    show_group_labels=False,
    show_extra_labels=True,
    show_extra_lines=True,
    sub_textures=sub_textures[0],
    bar_width=style_config['bar_width'],
    bar_spacing=style_config['bar_spacing'],
    group_spacing=style_config['group_spacing'],
    margin=style_config['margin'],
    label_offset=style_config['label_offset'],
    group_label_offset_x=style_config['group_label_offset_x'],
    group_label_offset_y=style_config['group_label_offset_y'],
)
create_stacked_subplot(
    main_ax1,
    labels=labels,
    label_ax=label_ax,
    extra_labels=extra_labels,
    stacked_values=percentages[1],
    ylabel='Normalized TOPS/W',
    ylabel_position=(-0.02, 0.3),
    ylimit=(0, 12),
    label_limit=10,
    fraction_bits=1,
    show_labels=True,
    show_group_labels=True,
    show_extra_labels=False,
    show_extra_lines=True,
    sub_textures=sub_textures[1],
    bar_width=style_config['bar_width'],
    bar_spacing=style_config['bar_spacing'],
    group_spacing=style_config['group_spacing'],
    margin=style_config['margin'],
    label_offset=style_config['label_offset'],
    group_label_offset_x=style_config['group_label_offset_x'],
    group_label_offset_y=style_config['group_label_offset_y'],
)

# Adjust layout
plt.tight_layout()
plt.subplots_adjust(hspace=0.05)  # Reduce space between subplots

# Export to PDF file
output_path = './results/fig_17.pdf'
plt.savefig(output_path, format='pdf', bbox_inches='tight', dpi=300)
print(f"Chart saved to: {output_path}")
